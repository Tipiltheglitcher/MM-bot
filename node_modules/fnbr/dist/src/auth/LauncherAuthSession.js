"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const AuthSession_1 = tslib_1.__importDefault(require("./AuthSession"));
const enums_1 = require("../../resources/enums");
const Endpoints_1 = tslib_1.__importDefault(require("../../resources/Endpoints"));
class LauncherAuthSession extends AuthSession_1.default {
    constructor(client, data, clientSecret) {
        super(client, data, clientSecret, enums_1.AuthSessionType.Launcher);
        this.app = data.app;
        this.clientsService = data.client_service;
        this.displayName = data.displayName;
        this.isInternalClient = data.internal_client;
        this.inAppId = data.in_app_id;
        this.scope = data.scope;
        this.refreshToken = data.refresh_token;
        this.refreshTokenExpiresAt = new Date(data.refresh_expires_at);
    }
    async verify(forceVerify = false) {
        if (!forceVerify && this.isExpired) {
            return false;
        }
        try {
            await this.client.http.epicgamesRequest({
                url: Endpoints_1.default.OAUTH_TOKEN_VERIFY,
                headers: {
                    Authorization: `bearer ${this.accessToken}`,
                },
            });
            return true;
        }
        catch (e) {
            return false;
        }
    }
    async createExchangeCode() {
        const response = await this.client.http.epicgamesRequest({
            url: Endpoints_1.default.OAUTH_EXCHANGE,
            headers: {
                Authorization: `bearer ${this.accessToken}`,
            },
        });
        return response.code;
    }
    async revoke() {
        clearTimeout(this.refreshTimeout);
        this.refreshTimeout = undefined;
        await this.client.http.epicgamesRequest({
            method: 'DELETE',
            url: `${Endpoints_1.default.OAUTH_TOKEN_KILL}/${this.accessToken}`,
            headers: {
                Authorization: `bearer ${this.accessToken}`,
            },
        });
    }
    async refresh() {
        this.refreshLock.lock();
        try {
            clearTimeout(this.refreshTimeout);
            this.refreshTimeout = undefined;
            const response = await this.client.http.epicgamesRequest({
                method: 'POST',
                url: Endpoints_1.default.OAUTH_TOKEN_CREATE,
                headers: {
                    Authorization: `basic ${Buffer.from(`${this.clientId}:${this.clientSecret}`).toString('base64')}`,
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                data: new URLSearchParams({
                    grant_type: 'refresh_token',
                    refresh_token: this.refreshToken,
                    token_type: 'eg1',
                }).toString(),
            });
            this.accessToken = response.access_token;
            this.expiresAt = new Date(response.expires_at);
            this.refreshToken = response.refresh_token;
            this.refreshTokenExpiresAt = new Date(response.refresh_expires_at);
            this.client.emit('refreshtoken:created', {
                accountId: this.accountId,
                clientId: this.clientId,
                displayName: this.displayName,
                expiresAt: this.refreshTokenExpiresAt.toISOString(),
                expiresIn: this.refreshTokenExpiresAt.getTime() - Date.now(),
                token: this.refreshToken,
            });
            this.initRefreshTimeout();
        }
        finally {
            this.refreshLock.unlock();
        }
    }
    initRefreshTimeout() {
        clearTimeout(this.refreshTimeout);
        this.refreshTimeout = setTimeout(() => this.refresh(), this.expiresAt.getTime() - Date.now() - 15 * 60 * 1000);
    }
    static async create(client, clientId, clientSecret, data) {
        const response = await client.http.epicgamesRequest({
            method: 'POST',
            url: Endpoints_1.default.OAUTH_TOKEN_CREATE,
            headers: {
                Authorization: `basic ${Buffer.from(`${clientId}:${clientSecret}`).toString('base64')}`,
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            data: new URLSearchParams(data).toString(),
        });
        const session = new LauncherAuthSession(client, response, clientSecret);
        session.initRefreshTimeout();
        client.emit('refreshtoken:created', {
            accountId: session.accountId,
            clientId: session.clientId,
            displayName: session.displayName,
            expiresAt: session.refreshTokenExpiresAt.toISOString(),
            expiresIn: Math.round((session.refreshTokenExpiresAt.getTime() - Date.now()) / 1000),
            token: session.refreshToken,
        });
        return session;
    }
}
exports.default = LauncherAuthSession;
//# sourceMappingURL=LauncherAuthSession.js.map